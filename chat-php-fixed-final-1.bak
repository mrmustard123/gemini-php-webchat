<?php
/*
File: chat.php - Versión final corregida
Author: Leonardo G. Tellez Saucedo
*/

// Desactivar warnings para evitar que contaminen la salida JSON
error_reporting(E_ERROR | E_PARSE);
ini_set('display_errors', 0);

// Iniciar output buffering limpio
if (ob_get_level()) {
    ob_end_clean();
}
ob_start();

require __DIR__ . '/vendor/autoload.php';

$dotenv = Dotenv\Dotenv::createImmutable(__DIR__);
$dotenv->load();

$apiKey = $_ENV['GEMINI_API_KEY'];
$model = $_ENV['MODEL'] ?? 'gemini-2.0-flash';

$sessionFile = __DIR__ . '/chat_session.json';

header('Content-Type: application/json; charset=utf-8');
header('Access-Control-Allow-Origin: *');
header('Access-Control-Allow-Methods: GET, POST, OPTIONS');
header('Access-Control-Allow-Headers: Content-Type');

function loadHistory($file) {
    if (file_exists($file)) {
        $data = json_decode(file_get_contents($file), true);
        // Asegurar que siempre devolvamos un array, no un objeto
        if (is_array($data) && isset($data['history']) && is_array($data['history'])) {
            return $data['history'];
        } elseif (is_array($data)) {
            // Si data es directamente el array de historia
            return array_values($data); // Reindexar para asegurar array numérico
        }
    }
    return [];
}

function saveHistory($file, $history) {
    // Guardar solo el array de historia, no envuelto en otro objeto
    $data = ['history' => array_values($history)]; // array_values para reindexar
    file_put_contents($file, json_encode($data, JSON_PRETTY_PRINT | JSON_UNESCAPED_UNICODE));
}

// Función para hacer petición HTTP sin cURL (con SSL corregido)
function makeHttpRequest($url, $data, $headers) {
    $context = stream_context_create([
        'http' => [
            'method' => 'POST',
            'header' => implode("\r\n", $headers) . "\r\n",
            'content' => $data,
            'timeout' => 30,
            'ignore_errors' => true
        ],
        'ssl' => [
            'verify_peer' => false,      // ¡Deshabilitar verificación SSL para desarrollo local!
            'verify_peer_name' => false,
            'allow_self_signed' => true,
        ]
    ]);

    $response = @file_get_contents($url, false, $context);
    
    if ($response === false) {
        // Si falla, intentar obtener más información del error
        $error = error_get_last();
        throw new Exception('HTTP request failed: ' . ($error['message'] ?? 'Unknown error'));
    }
    
    // Obtener código de respuesta HTTP
    $httpCode = 200;
    if (isset($http_response_header)) {
        foreach ($http_response_header as $header) {
            if (preg_match('/HTTP\/\d\.\d\s+(\d+)/', $header, $matches)) {
                $httpCode = intval($matches[1]);
                break;
            }
        }
    }
    
    return [
        'response' => $response,
        'http_code' => $httpCode,
        'headers' => $http_response_header ?? []
    ];
}

// Manejo de OPTIONS para CORS
if ($_SERVER['REQUEST_METHOD'] === 'OPTIONS') {
    ob_end_clean();
    http_response_code(200);
    exit;
}

// Manejo de GET: devolver historial
if ($_SERVER['REQUEST_METHOD'] === 'GET') {
    ob_end_clean(); // Limpiar buffer
    $history = loadHistory($sessionFile);
    echo json_encode(['history' => $history], JSON_UNESCAPED_UNICODE);
    exit;
}

// Manejo de POST: enviar mensaje al modelo y actualizar historial
if ($_SERVER['REQUEST_METHOD'] === 'POST') {
    try {
        $rawInput = file_get_contents('php://input');
        $input = json_decode($rawInput, true);
        
        if (json_last_error() !== JSON_ERROR_NONE) {
            throw new Exception('JSON inválido: ' . json_last_error_msg());
        }
        
        $message = trim($input['message'] ?? '');

        if ($message === '') {
            throw new Exception('Mensaje vacío');
        }

        // Cargar historial
        $history = loadHistory($sessionFile);

        // Convertir historial al formato esperado por Gemini 2.0
        $geminiContents = [];
        
        if (is_array($history)) {
            foreach ($history as $turn) {
                // Verificar que el turn tenga la estructura correcta
                if (is_array($turn) && 
                    isset($turn['role']) && 
                    isset($turn['parts']) && 
                    is_array($turn['parts']) && 
                    isset($turn['parts'][0]['text'])) {
                    
                    $geminiContents[] = [
                        'parts' => [['text' => $turn['parts'][0]['text']]]
                    ];
                }
            }
        }

        // Añadir el mensaje del usuario actual
        $geminiContents[] = [
            'parts' => [['text' => $message]]
        ];

        // Preparar payload para Gemini
        $payload = [
            'contents' => $geminiContents
        ];
        
        $url_gemini = "https://generativelanguage.googleapis.com/v1beta/models/$model:generateContent";
        $jsonPayload = json_encode($payload);
        
        $headers = [
            'Content-Type: application/json',
            'X-goog-api-key: ' . $apiKey,
            'User-Agent: PHP-Gemini-Client/2.0'
        ];

        $result = makeHttpRequest($url_gemini, $jsonPayload, $headers);

        if ($result['http_code'] !== 200) {
            // Intentar parsear el error de Gemini
            $errorData = json_decode($result['response'], true);
            if ($errorData && isset($errorData['error'])) {
                $errorMsg = $errorData['error']['message'] ?? 'Error desconocido de Gemini';
                $errorCode = $errorData['error']['code'] ?? $result['http_code'];
                throw new Exception("Gemini API Error ($errorCode): $errorMsg");
            } else {
                throw new Exception("HTTP {$result['http_code']}: {$result['response']}");
            }
        }

        $responseData = json_decode($result['response'], true);
        
        if (json_last_error() !== JSON_ERROR_NONE) {
            throw new Exception('Respuesta JSON inválida de Gemini');
        }

        // Verificar estructura de respuesta
        if (!isset($responseData['candidates'][0]['content']['parts'][0]['text'])) {
            throw new Exception('Estructura de respuesta inesperada de Gemini');
        }

        $reply = $responseData['candidates'][0]['content']['parts'][0]['text'];

        // Actualizar historial con estructura correcta
        $userMessage = [
            'role' => 'user',
            'parts' => [['text' => $message]]
        ];
        $modelMessage = [
            'role' => 'model',
            'parts' => [['text' => $reply]]
        ];
        
        $history[] = $userMessage;
        $history[] = $modelMessage;

        // Guardar historial
        saveHistory($sessionFile, $history);

        // Limpiar buffer y enviar respuesta
        ob_end_clean();
        echo json_encode([
            'reply' => $reply,
            'history' => $history
        ], JSON_UNESCAPED_UNICODE);
        
    } catch (Exception $e) {
        ob_end_clean();
        echo json_encode(['error' => $e->getMessage()], JSON_UNESCAPED_UNICODE);
    }
    exit;
}

// Si no es GET ni POST
ob_end_clean();
http_response_code(405);
echo json_encode(['error' => 'Método no permitido'], JSON_UNESCAPED_UNICODE);
?>